### 并发和并行
+ 并发：同一时刻，多个任务交替执行，造成一种“貌似同时”的错觉，单核CPU实现的多任务就是并发
+ 并行：同一时刻，多个任务同时执行，多核CPU可以实现并行

### 创建新的执行线程：
+ 一个是将一个类声明为Thread的子类。 这个子类应该重写run类的方法Thread 。 然后可以分配并启动子类的实例。
+ 另一种方法来创建一个线程是声明实现类Runnable接口。 那个类然后实现了run方法。 然后可以分配类的实例，在创建Thread时作为参数传递，并启动。

### 说明：
    每个线程都有一个用于识别目的的名称。 多个线程可能具有相同的名称。 如果在创建线程时未指定名称，则会为其生成一个新名称。
        像Thread-0、Thread-1、Thread-2、...
    主线程结束不会导致子线程结束，只要有线程没有运行完就程序就不会结束

### 线程终止
1. 线程完成任务后自动退出或因为异常而退出
2. 通过使用变量来控制run方法退出方式停止线程

### 用户线程和守护线程
+ 用户线程：也叫工作线程，当线程的任务执行完或通知方式结束
+ 守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束。常见的守护线程：垃圾回收装置

### 线程的生命周期
    Thread.State   Thread的内部枚举类，表示线程状态
        NEW             (刚创建的)尚未启动的线程处于此状态。
        RUNNABLE        (可运行的)在Java虚拟机中执行的线程处于此状态。
         一旦调用start方法，线程就进入了可运行状态，一个可运行的线程可能正在运行也可能没有运行。要由操作系统为线程提供具体的运行时间
        BLOCKED         (阻塞)被阻塞等待监视器锁定的线程处于此状态。
        WAITING         (等待)正在等待另一个线程执行特定动作的线程处于此状态。
        TIMED_WAITING   (超时等待)正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。
        TERMINATED      (终止)已退出的线程处于此状态。


### 为什么废弃stop和suspend方法？

1. 为什么废弃stop

    **stop方法不安全**

    当线程被stop方法终止，它会立即释放它锁定的所有对象的锁，这会导致对象处于不一致的状态。比如银行转账，钱拿出来了还没有给别人线程就被终止了，没有回滚
操作。当一个线程要终止另一个线程时，他不知道什么时候调用stop方法是安全的。因此，该方法被废弃。希望停止一个线程的时候应该中断该线程，被中断的线程检
测到被中断可以在安全的时候终止。

2. 为什么废弃suspend方法

    **suspend方法容易发生死锁**

    用一个线程用suspend方法挂起另一个持有锁的线程，如果这时候调用suspend方法的线程试图获取同一个锁，程序就会死锁。被挂起的线程等着被恢复，而将其挂起
的线程等待获得锁







