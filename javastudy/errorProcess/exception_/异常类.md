异常类知识点
============

1. 方法抛出的异常会使用异常处理机制搜索能够处理该异常状况的异常处理机制
2. 所有的异常都由`Throwable类`继承而来
3. `Error类`层次结构描述了java运行时系统的内部错误和资源耗尽错误。如果出现了这种错误，就只能尽力妥善地终止程序了
4. 由编译错误导致的异常属于`RuntimeException`，出现这种错误一般是你自己的责任
5. 如果程序本身没有问题，但是由于像I/O错误这类问题导致的异常属于`其他异常`
6. 派生与Error类或RuntimeException类的所有异常称为`非检查型`，所有的其他异常称为`检查型异常`
7. 在方法首部声明抛出的异常时不需要声明java的内部错误(Error继承的异常)，因为任何代码都可能抛出那些异常，对此我们无法控制
8. 在继承方面

> 如果子类覆盖了超类的一个方法，子类方法中声明的异常不能比超类方法中声明的方法更通用(如果超类中声明RuntimeException，子类就不能是NullPointException)，当然子类也可以不抛出异常 
>
> 如果超类中没有抛出任何检查型异常，子类也不能抛出任何检查型异常，但是子类可以抛出非检查型异常

9. 是选择抛出一个异常还是捕获？ 
   + 一般规律是捕获你知道如何处理的异常，继续抛出你不知道如何处理的异常
   + 但是特殊情况是子类继承超类重写了方法，超类没有抛出检查型异常，子类就得自己处理检查型异常了(也可以捕获后包装成运行时异常抛出去)


异常使用的一些技巧
=================
1. 异常处理不能代替简单的测试
   与完成简单的测试相比，异常捕获花费的事件大大超过了前者，因此最好在异常情况下使用异常
2. 在检测错误时，”苛刻“要比放任好
   在用无效的参数调用一个方法时，返回一个虚拟值是不是比抛出一个异常更好？例如，当栈为空时，Stack.pop是返回null还是抛出一个异常？我们认为抛出一个
   个EmptyStackException要比以后抛出一个NullPointException要好
3. 早抛出，晚捕获

