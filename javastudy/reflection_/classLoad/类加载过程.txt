注意是类加载，不是创建对象


------------
java源码
Cat.java
------------
    |
    |
    |
javac编译
    |
    |
    |
------------
字节码文件
Cat.class
------------
    |
    |
    |
 java运行
    |
    |
    |
------------
加载(Loading)     (1)JVM在该阶段的主要目的是将字节码从不同的数据源(可能是class文件、也可能是jar包，甚至是网络)转化为二进制字节流加载到内存中，并生成
------------        一个代表该类的java.lang.Class对象
    |
    |
    |
    |
    |
    |
------------
连接(Linking)
    验证(verification)    (1)目的是为了确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全
        |                (2)包括: 文件格式验证(是否以oxcafe babe开头)、元数据验证、字节码验证和符号引用验证
        |                (3)可以使用 -Xverify:none 参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间
        |
    准备(preparation)     (1)JVM会在该阶段对 静态变量 分配内存并初始化(对应数据类型的默认初始值，如0 0L null false等)，这些变量所使用的内容都将在
        |                   方法区进行分配
        |
        |
    解析(resolution)      (1)虚拟机将常量池内的 符号引用 替换为 直接引用 的过程
------------
    |
    |
    |
    |
    |
    |
------------
初始化(initialization) (1)初始化阶段才真正开始执行类中定义的java程序代码，此阶段是执行类构造器即<clinit>方法的过程
------------          (2)<clinit>()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句，并进行合并
                      (3)虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行
                        这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕
                      (4)在执行子类前，会先执行父类的<clinit>方法
                      (5)接口中也有<clinit>方法，但实现类初始化或子类接口执行<clinit>方法时，不会执行父接口的<clinit>。而是要等到父接口定义变量使
                        用时才会调用clinit。
                      (6)无clinit的情况
                        没有声明任何类变量、没有static块语句
                        声明了类变量，但没有对应的变量初始化语句
                        只有final类变量，且赋值语句是常量（如 final static int danlu = 1;）。这样的赋值会在准备阶段就执行
